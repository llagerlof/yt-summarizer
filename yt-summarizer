#!/usr/bin/env bash

VERSION="1.2.1"

CONFIG_FILE="$HOME/.config/yt-summarizer.conf"
LOG_FILE="./yt-summarizer.log"
OPEN_EDITOR=false

# Function to log messages with timestamp
log() {
  local level="$1"
  shift
  local message="$*"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE" >&2
}

usage() {
  echo "yt-summarizer $VERSION"
  echo "Usage: yt-summarizer [-e] <youtube url>"
  echo "Options:"
  echo "  -e    Open the summary file with an editor after generation"
  echo "  -h    Show this help message"
  echo "  -v    Show version"
}

# Function to check if running in a graphical environment
is_graphical() {
  [[ -n "$DISPLAY" || -n "$WAYLAND_DISPLAY" ]]
}

# Function to try opening file with an editor
open_with_editor() {
  local file="$1"
  local editors=()
  
  # Add desktop editors if in graphical environment
  if is_graphical; then
    editors+=(kate kwrite gnome-text-editor)
  fi
  
  # Add CLI editors
  editors+=(nvim vim vi less)
  
  # Try each editor
  for editor in "${editors[@]}"; do
    if command -v "$editor" >/dev/null 2>&1; then
      log "INFO" "Opening file with $editor"
      case "$editor" in
        less)
          "$editor" "$file"
          ;;
        *)
          "$editor" "$file" &
          ;;
      esac
      return 0
    fi
  done
  
  log "WARN" "No suitable editor found"
  return 1
}

init_config() {
  mkdir -p "$(dirname "$CONFIG_FILE")"
  cat > "$CONFIG_FILE" <<'EOC'
OpenAIAPIKey=
OpenAIModel=gpt-3.5-turbo
DefaultPrompt="This is a YouTube transcription text. Create a detailed, well explained summary of this transcription. Make the text look like it was written by a human. Be serious but use a casual tone, focus on the important aspects of the subjects. If the transcription has explanations on how to do something, include these explanations in the summary organized by topics. A better explained text must be prioritized over shortness. You can use bullet points in some parts if the context if it is relevant. Organize the summary in sections and add a brief title before each section. Each section can have one or more paragraphs. If people's names are mentioned in the text you must also mention the name (and the person's role/task if available) in the summary. Write the summary in english in markdown format."
EOC
  echo "Configuration file created at $CONFIG_FILE"
  echo "Please edit this file and set OpenAIAPIKey before running the script again."
}

# Function to clean up temporary files
cleanup() {
  log "INFO" "Cleaning up temporary files..."
  # Keep VTT files and summary files, only clean up other temp files if any
  # No cleanup needed since we want to preserve the VTT file
  true
}

# Set up cleanup trap
trap cleanup EXIT

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
  usage
  exit 0
fi

if [[ "$1" == "-v" || "$1" == "--version" ]]; then
  echo "$VERSION"
  exit 0
fi

if [[ "$1" == "-e" ]]; then
  OPEN_EDITOR=true
  shift
fi

if [[ -z "$1" ]]; then
  usage
  exit 1
fi

URL="$1"
log "INFO" "Starting yt-summarizer for URL: $URL"

if [[ ! -f "$CONFIG_FILE" ]]; then
  log "ERROR" "Config file not found, initializing..."
  init_config
  exit 1
fi

# shellcheck disable=SC1090
source "$CONFIG_FILE"

if [[ -z "$OpenAIAPIKey" ]]; then
  log "ERROR" "OpenAIAPIKey is not set in $CONFIG_FILE"
  exit 1
fi

if [[ -z "$OpenAIModel" ]]; then
  log "ERROR" "OpenAIModel is not set in $CONFIG_FILE"
  exit 1
fi

if [[ -z "$DefaultPrompt" ]]; then
  log "ERROR" "DefaultPrompt is not set in $CONFIG_FILE"
  exit 1
fi

# Get video information
log "INFO" "Fetching video information..."
title="$(yt-dlp --print '%(title)s' "$URL" 2>/dev/null)"
if [[ -z "$title" ]]; then
  log "ERROR" "Failed to get video title. URL might be invalid or yt-dlp failed."
  exit 1
fi

lang="$(yt-dlp --print '%(language)s' "$URL" 2>/dev/null)"
if [[ -z "$lang" || "$lang" == "None" ]]; then
  lang="en"
  log "INFO" "Video language not detected, defaulting to English"
else
  log "INFO" "Video language detected as: $lang"
fi

log "INFO" "Video title: $title"

# Function to try downloading subtitles
download_subtitles() {
  local sub_type="$1"  # "official" or "auto"
  local sub_lang="$2"
  local attempt_desc="$3"
  
  log "INFO" "Attempting to download $attempt_desc..."
  
  # Store the count of .vtt files before download
  local vtt_count_before=$(ls *.vtt 2>/dev/null | wc -l)
  log "INFO" "VTT files before download: $vtt_count_before"
  
  local cmd_result=0
  if [[ "$sub_type" == "official" ]]; then
    yt-dlp --skip-download --write-sub --sub-lang "$sub_lang" --convert-subs vtt -o "%(title)s.%(ext)s" "$URL" >/dev/null 2>>"$LOG_FILE" || cmd_result=$?
  else
    yt-dlp --skip-download --write-auto-sub --sub-lang "$sub_lang" --convert-subs vtt -o "%(title)s.%(ext)s" "$URL" >/dev/null 2>>"$LOG_FILE" || cmd_result=$?
  fi
  
  log "INFO" "yt-dlp command result: $cmd_result"
  
  # Check if new .vtt files were created
  local vtt_count_after=$(ls *.vtt 2>/dev/null | wc -l)
  log "INFO" "VTT files after download: $vtt_count_after"
  
  if [[ $vtt_count_after -gt $vtt_count_before ]]; then
    # Find the most recently created .vtt file
    local newest_file=$(ls -t *.vtt 2>/dev/null | head -1)
    if [[ -n "$newest_file" && -f "$newest_file" ]]; then
      # Check if the VTT file contains actual text
      if grep -q -v -E '^(WEBVTT|Kind:|Language:|[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3} -->|^\s*$)' "$newest_file"; then
        log "INFO" "Successfully downloaded subtitles with text: $newest_file"
        echo "$newest_file"
        return 0
      else
        log "WARN" "Downloaded subtitle file '$newest_file' appears to be empty or contain only timestamps. Discarding."
        rm "$newest_file"
      fi
    fi
  fi
  
  log "WARN" "Failed to download $attempt_desc"
  return 1
}

# Try to download subtitles with fallback strategy
log "INFO" "Starting subtitle download with fallback strategy..."

sub_file=""

# 1. Try official subtitles in video language
if [[ -z "$sub_file" ]]; then
  log "INFO" "Trying attempt 1: official subtitles"
  sub_file=$(download_subtitles "official" "$lang" "official subtitles in $lang")
  log "INFO" "Attempt 1 result: sub_file='$sub_file'"
fi

# 2. Try auto-generated subtitles in preferred languages first
if [[ -z "$sub_file" ]]; then
  log "INFO" "Trying attempt 2: auto-generated English subtitles"
  sub_file=$(download_subtitles "auto" "en" "auto-generated English subtitles")
  log "INFO" "Attempt 2 result: sub_file='$sub_file'"
fi

if [[ -z "$sub_file" ]]; then
  log "INFO" "Trying attempt 3: auto-generated Brazilian Portuguese subtitles"
  sub_file=$(download_subtitles "auto" "pt-BR" "auto-generated Brazilian Portuguese subtitles")
  log "INFO" "Attempt 3 result: sub_file='$sub_file'"
fi

if [[ -z "$sub_file" ]]; then
  log "INFO" "Trying attempt 4: auto-generated European Portuguese subtitles"
  sub_file=$(download_subtitles "auto" "pt" "auto-generated European Portuguese subtitles")
  log "INFO" "Attempt 4 result: sub_file='$sub_file'"
fi

# 3. Try auto-generated subtitles in video language if not already tried
if [[ -z "$sub_file" && "$lang" != "en" && "$lang" != "pt-BR" && "$lang" != "pt" ]]; then
  log "INFO" "Trying attempt 5: auto-generated subtitles in $lang"
  sub_file=$(download_subtitles "auto" "$lang" "auto-generated subtitles in $lang")
  log "INFO" "Attempt 5 result: sub_file='$sub_file'"
fi

# 4. Final check - list all .vtt files and try to use any available
if [[ -z "$sub_file" ]]; then
  log "INFO" "Checking for any available subtitle files..."
  vtt_files=(*.vtt)
  if [[ -f "${vtt_files[0]}" ]]; then
    sub_file="${vtt_files[0]}"
    log "INFO" "Found subtitle file: $sub_file"
  fi
fi

if [[ -z "$sub_file" || ! -f "$sub_file" ]]; then
  log "ERROR" "Failed to download any subtitles. Available subtitle languages might be:"
  yt-dlp --list-subs "$URL" 2>>"$LOG_FILE" | tee -a "$LOG_FILE" || true
  exit 1
fi

log "INFO" "Using subtitle file: $sub_file"

base="$title"

# Keep the original VTT file and send it directly to OpenAI
log "INFO" "Using original VTT file: $sub_file"

# Check if VTT file is not empty
if [[ ! -s "$sub_file" ]]; then
  log "ERROR" "VTT file is empty or corrupted."
  log "INFO" "VTT file contents:"
  head -20 "$sub_file" | tee -a "$LOG_FILE"
  exit 1
fi

vtt_size=$(wc -c < "$sub_file")
log "INFO" "VTT file size: $vtt_size characters"

if [[ $vtt_size -lt 50 ]]; then
  log "WARN" "VTT file seems very short, this might indicate a problem"
fi

# Read the entire VTT file content to send to OpenAI
log "INFO" "Creating OpenAI API request..."

# Create a temporary JSON file to avoid argument list too long error
json_temp_file=$(mktemp)
trap "rm -f '$json_temp_file'" EXIT

# Use jq to create the JSON payload and write it to a file
jq -n \
  --arg model "$OpenAIModel" \
  --arg prompt "$DefaultPrompt" \
  --rawfile text "$sub_file" \
  '{model:$model,messages:[{"role":"user","content":("<task>" + $prompt + "</task><transcript>" + $text + "</transcript>")}]}' \
  > "$json_temp_file"

log "INFO" "Sending request to OpenAI API..."
response=$(curl -sS https://api.openai.com/v1/chat/completions \
  -H "Authorization: Bearer $OpenAIAPIKey" \
  -H 'Content-Type: application/json' \
  -d @"$json_temp_file" 2>>"$LOG_FILE")

if [[ -z "$response" ]]; then
  log "ERROR" "Empty response from OpenAI API"
  exit 1
fi

# Check for API errors
if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
  error_message=$(echo "$response" | jq -r '.error.message')
  log "ERROR" "OpenAI API error: $error_message"
  exit 1
fi

summary=$(echo "$response" | jq -r '.choices[0].message.content')

if [[ -z "$summary" || "$summary" == "null" ]]; then
  log "ERROR" "Failed to extract summary from API response"
  log "INFO" "API response: $response"
  exit 1
fi

timestamp=$(date +%F_%H-%M-%S)
output_file="${base}_${timestamp}.txt"

echo "$summary" > "$output_file"
log "INFO" "Summary written to: $output_file"

echo "Original VTT file: $sub_file"
echo "Summary written to $output_file"
log "INFO" "yt-summarizer completed successfully"

# Open the file with an editor if requested
if [[ "$OPEN_EDITOR" == "true" ]]; then
  open_with_editor "$output_file"
fi

