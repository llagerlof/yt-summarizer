#!/usr/bin/env bash

VERSION="1.5.1"

CONFIG_FILE="$HOME/.config/yt-summarizer.conf"
LOG_FILE="./yt-summarizer.log"
OPEN_EDITOR=false
PROCESSING_STARTED="false"

# Function to log messages with timestamp
log() {
  local level="$1"
  shift
  local message="$*"
  local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE" >&2
}

usage() {
  echo "yt-summarizer $VERSION"
  echo "Usage: yt-summarizer [-e] <youtube url>"
  echo "Options:"
  echo "  -e    Open the summary file with an editor after generation"
  echo "  -h    Show this help message"
  echo "  -v    Show version"
}

# Function to check if running in a graphical environment
is_graphical() {
  [[ -n "$DISPLAY" || -n "$WAYLAND_DISPLAY" ]]
}

# Function to try opening file with an editor
open_with_editor() {
  local file="$1"
  local editors=()
  
  # Add desktop editors if in graphical environment
  if is_graphical; then
    editors+=(kate kwrite gnome-text-editor)
  fi
  
  # Add CLI editors
  editors+=(nvim vim vi less)
  # Fallback to system opener
  editors+=(xdg-open)
  
  # Try each editor
  for editor in "${editors[@]}"; do
    if command -v "$editor" >/dev/null 2>&1; then
      log "INFO" "Opening file with $editor"
      case "$editor" in
        less)
          "$editor" "$file"
          ;;
        xdg-open)
          "$editor" "$file" >/dev/null 2>&1 &
          ;;
        *)
          "$editor" "$file" &
          ;;
      esac
      return 0
    fi
  done
  
  log "WARN" "No suitable editor found"
  return 1
}

init_config() {
  mkdir -p "$(dirname "$CONFIG_FILE")"
  cat > "$CONFIG_FILE" <<'EOC'
OpenAIAPIKey=
# Default to a widely supported chat model
OpenAIModel=gpt-4o-mini
DefaultPrompt="This is a YouTube transcription text. Create a detailed, well explained summary of this transcription. Make the text look like it was written by a human. Be serious but use a casual tone, focus on the important aspects of the subjects. If the transcription has explanations on how to do something, include these explanations in the summary organized by topics. A better explained text must be prioritized over shortness. You can use bullet points in some parts if the context if it is relevant. Organize the summary in sections and add a brief title before each section. Each section can have one or more paragraphs. If people's names are mentioned in the text you must also mention the name (and the person's role/task if available) in the summary. Write the summary in english in markdown format."
EOC
  echo "Configuration file created at $CONFIG_FILE"
  echo "Please edit this file and set OpenAIAPIKey before running the script again."
  chmod 600 "$CONFIG_FILE" 2>/dev/null || true
}

# Function to clean up temporary files and perform finalization
cleanup() {
  log "INFO" "Cleaning up temporary files..."
  # Remove temporary subtitles directory (all non-selected subtitle files)
  if [[ -n "${subs_dir:-}" && -d "${subs_dir}" ]]; then
    rm -rf "${subs_dir}" || true
  fi
}

# Consolidated EXIT trap to avoid being overwritten later
on_exit() {
  if [[ "$PROCESSING_STARTED" == "true" ]]; then
    cleanup || true
  fi
  # Remove temporary JSON file if it exists
  if [[ -n "${json_temp_file:-}" && -f "${json_temp_file}" ]]; then
    rm -f "${json_temp_file}" || true
  fi
}

trap on_exit EXIT

# Check for required external dependencies early
check_dependencies() {
  local missing=()
  local deps=(yt-dlp jq curl)
  for dep in "${deps[@]}"; do
    if ! command -v "$dep" >/dev/null 2>&1; then
      missing+=("$dep")
    fi
  done
  if (( ${#missing[@]} > 0 )); then
    log "ERROR" "Missing required commands: ${missing[*]}. Please install them and try again."
    exit 1
  fi
}

# Clean a VTT file to reduce token usage while keeping useful content
# - Trims cue settings after the main timestamp (e.g., align:start position:0%)
# - Removes all tags like <c>...</c>, <i>...</i>, <00:00:00.000>, <v Name>...
# - Collapses repeated spaces and trims leading/trailing spaces on text lines
clean_vtt_file() {
  local input_file="$1"
  local output_file="$2"

  if [[ -z "$input_file" || -z "$output_file" ]]; then
    log "ERROR" "clean_vtt_file requires input and output paths"
    return 1
  fi

  # Use sed to:
  # 1) Keep only the two timestamps on cue timing lines
  # 2) Remove any tags between angle brackets
  # 3) Trim leading/trailing whitespace and collapse multiple spaces
  sed -E \
    -e 's/^([0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3} --> [0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}).*/\1/' \
    -e 's/<[^>]*>//g' \
    -e 's/^[[:space:]]+//; s/[[:space:]]+$//' \
    -e 's/[[:space:]]{2,}/ /g' \
    "$input_file" > "$output_file"
}

if [[ "$1" == "-h" || "$1" == "--help" ]]; then
  usage
  exit 0
fi

if [[ "$1" == "-v" || "$1" == "--version" ]]; then
  echo "$VERSION"
  exit 0
fi

if [[ "$1" == "-e" ]]; then
  OPEN_EDITOR=true
  shift
fi

if [[ -z "$1" ]]; then
  usage
  exit 1
fi

URL="$1"
PROCESSING_STARTED="true"
log "INFO" "Starting yt-summarizer $VERSION for URL: $URL"

# Ensure needed tools are available
check_dependencies

if [[ ! -f "$CONFIG_FILE" ]]; then
  log "ERROR" "Config file not found, initializing..."
  init_config
  exit 1
fi

# shellcheck disable=SC1090
source "$CONFIG_FILE"

if [[ -z "$OpenAIAPIKey" ]]; then
  log "ERROR" "OpenAIAPIKey is not set in $CONFIG_FILE"
  exit 1
fi

if [[ -z "$OpenAIModel" ]]; then
  log "ERROR" "OpenAIModel is not set in $CONFIG_FILE"
  exit 1
fi

if [[ -z "$DefaultPrompt" ]]; then
  log "ERROR" "DefaultPrompt is not set in $CONFIG_FILE"
  exit 1
fi

# Get video information
log "INFO" "Fetching video information..."
title="$(yt-dlp --print '%(title)s' "$URL" 2>/dev/null)"
if [[ -z "$title" ]]; then
  log "ERROR" "Failed to get video title. URL might be invalid or yt-dlp failed."
  exit 1
fi

# Always get a stable video id for file naming and isolation
video_id="$(yt-dlp --print '%(id)s' "$URL" 2>/dev/null)"
if [[ -z "$video_id" ]]; then
  log "ERROR" "Failed to get video id."
  exit 1
fi

lang="$(yt-dlp --print '%(language)s' "$URL" 2>/dev/null)"
# Treat unknown markers as not detected
if [[ -z "$lang" || "$lang" == "None" || "$lang" == "NA" || "$lang" == "N/A" || "$lang" == "na" ]]; then
  lang="en"
  log "INFO" "Video language not detected, defaulting to English"
else
  log "INFO" "Video language detected as: $lang"
fi

log "INFO" "Video title: $title"

# Create an isolated temporary directory for subtitle downloads
subs_dir=$(mktemp -d)
if [[ ! -d "$subs_dir" ]]; then
  log "ERROR" "Failed to create temporary directory for subtitles"
  exit 1
fi
log "INFO" "Using temporary subtitles directory: $subs_dir"

# Build preferred subtitle language lists
preferred_langs_official="${lang},${lang}.*"
preferred_langs_auto="${lang},${lang}-orig,${lang}.*"

# Function to try downloading subtitles (any language)
download_subtitles() {
  local sub_type="$1"  # "official" or "auto"
  local attempt_desc="$2"
  
  log "INFO" "Attempting to download $attempt_desc..."
  
  # Store the count of .vtt files before download
  local vtt_count_before=$(ls "$subs_dir"/*.vtt 2>/dev/null | wc -l)
  log "INFO" "VTT files before download: $vtt_count_before"
  
  local cmd_result=0
  if [[ "$sub_type" == "official" ]]; then
    yt-dlp \
      --skip-download \
      --write-sub \
      --sub-langs "${SUB_LANGS:-$preferred_langs_official}" \
      --sub-format "vtt/srv3" \
      --convert-subs vtt \
      --paths subtitle:"$subs_dir" \
      -o "%(id)s.%(ext)s" \
      "$URL" >/dev/null 2>>"$LOG_FILE" || cmd_result=$?
  else
    yt-dlp \
      --skip-download \
      --write-auto-sub \
      --sub-langs "${SUB_LANGS:-$preferred_langs_auto}" \
      --sub-format "vtt/srv3" \
      --convert-subs vtt \
      --paths subtitle:"$subs_dir" \
      -o "%(id)s.%(ext)s" \
      "$URL" >/dev/null 2>>"$LOG_FILE" || cmd_result=$?
  fi
  
  log "INFO" "yt-dlp command result: $cmd_result"
  
  # Check if new .vtt files were created
  local vtt_count_after=$(ls "$subs_dir"/*.vtt 2>/dev/null | wc -l)
  log "INFO" "VTT files after download: $vtt_count_after"
  
  if [[ $vtt_count_after -gt $vtt_count_before ]]; then
    # Find the most recently created .vtt file
    local newest_file=$(ls -t "$subs_dir"/*.vtt 2>/dev/null | head -1)
    if [[ -n "$newest_file" && -f "$newest_file" ]]; then
      # Check if the VTT file contains actual text
      if grep -q -v -E '^(WEBVTT|Kind:|Language:|[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3} -->|[[:space:]]*)$' "$newest_file"; then
        log "INFO" "Successfully downloaded subtitles with text: $newest_file"
        echo "$newest_file"
        return 0
      else
        log "WARN" "Downloaded subtitle file '$newest_file' appears to be empty or contain only timestamps. Discarding."
        rm "$newest_file"
      fi
    fi
  fi
  
  log "WARN" "Failed to download $attempt_desc"
  return 1
}

# Try to download subtitles with simplified strategy
log "INFO" "Starting subtitle download (official first, then automatic), preferred languages..."

sub_file=""

# 1) Try official subtitles (any language)
if [[ -z "$sub_file" ]]; then
  log "INFO" "Trying official subtitles (preferred languages)"
  SUB_LANGS="$preferred_langs_official"
  sub_file=$(download_subtitles "official" "official subtitles (preferred languages)")
  log "INFO" "Official attempt result: sub_file='$sub_file'"
fi

# 2) Fallback: automatic subtitles (any language)
if [[ -z "$sub_file" ]]; then
  log "INFO" "Trying automatic subtitles (preferred languages)"
  SUB_LANGS="$preferred_langs_auto"
  sub_file=$(download_subtitles "auto" "automatic subtitles (preferred languages)")
  log "INFO" "Automatic attempt result: sub_file='$sub_file'"
fi

# 3) Fallback: automatic English subtitles explicitly (avoid requesting all languages)
if [[ -z "$sub_file" && "$lang" != "en" ]]; then
  log "INFO" "Trying automatic subtitles (English fallback)"
  SUB_LANGS="en.*"
  sub_file=$(download_subtitles "auto" "automatic subtitles (English fallback)")
  log "INFO" "Automatic English fallback result: sub_file='$sub_file'"
fi

if [[ -z "$sub_file" || ! -f "$sub_file" ]]; then
  log "ERROR" "Failed to download any subtitles. Available subtitle languages might be:"
  yt-dlp --list-subs "$URL" 2>>"$LOG_FILE" | tee -a "$LOG_FILE" || true
  exit 1
fi

log "INFO" "Using subtitle file: $sub_file"

base="$title"

# Create a cleaned VTT file to reduce tokens
log "INFO" "Cleaning VTT file before sending to OpenAI"
clean_sub_file=$(mktemp)
if clean_vtt_file "$sub_file" "$clean_sub_file"; then
  :
else
  log "WARN" "Cleaning failed; proceeding with original VTT"
  rm -f "$clean_sub_file" 2>/dev/null || true
  clean_sub_file="$sub_file"
fi

# Check if VTT file is not empty
if [[ ! -s "$sub_file" ]]; then
  log "ERROR" "VTT file is empty or corrupted."
  log "INFO" "VTT file contents:"
  head -20 "$sub_file" | tee -a "$LOG_FILE"
  exit 1
fi

vtt_size=$(wc -c < "$sub_file")
clean_vtt_size=$(wc -c < "$clean_sub_file")
log "INFO" "Original VTT size: $vtt_size characters"
log "INFO" "Cleaned VTT size: $clean_vtt_size characters"

if [[ $vtt_size -lt 50 ]]; then
  log "WARN" "VTT file seems very short, this might indicate a problem"
fi

# Read the cleaned VTT file content to send to OpenAI
log "INFO" "Creating OpenAI API request..."

# Create a temporary JSON file to avoid argument list too long error
json_temp_file=$(mktemp)

# Use jq to create the JSON payload and write it to a file
jq -n \
  --arg model "$OpenAIModel" \
  --arg prompt "$DefaultPrompt" \
  --rawfile text "$clean_sub_file" \
  '{model:$model,messages:[{"role":"user","content":("<task>" + $prompt + "</task><transcript>" + $text + "</transcript>")}]}' \
  > "$json_temp_file"

log "INFO" "Sending request to OpenAI API..."
response=$(curl -sS https://api.openai.com/v1/chat/completions \
  -H "Authorization: Bearer $OpenAIAPIKey" \
  -H 'Content-Type: application/json' \
  -d @"$json_temp_file" 2>>"$LOG_FILE")

if [[ -z "$response" ]]; then
  log "ERROR" "Empty response from OpenAI API"
  exit 1
fi

# Check for API errors
if echo "$response" | jq -e '.error' >/dev/null 2>&1; then
  error_message=$(echo "$response" | jq -r '.error.message')
  log "ERROR" "OpenAI API error: $error_message"
  exit 1
fi

summary=$(echo "$response" | jq -r '.choices[0].message.content')

if [[ -z "$summary" || "$summary" == "null" ]]; then
  log "ERROR" "Failed to extract summary from API response"
  log "INFO" "API response: $response"
  exit 1
fi

# Sanitize the title for a safe output filename
sanitize_title() {
  local t="$1"
  # Replace path separators with dashes
  t=${t//\//-}
  t=${t//\\/-}
  # Replace characters that are problematic on many filesystems
  t=${t//:/-}
  t=${t//\*/-}
  t=${t//\?/-}
  t=${t//\"/-}
  t=${t//</-}
  t=${t//>/-}
  t=${t//|/-}
  # Collapse whitespace and trim
  t=$(printf '%s' "$t" | sed 's/[[:space:]]\+/ /g; s/^ //; s/ $//')
  printf '%s' "$t"
}

timestamp=$(date +%F_%H-%M-%S)
safe_title=$(sanitize_title "$title")
output_file="${safe_title}_${timestamp}_summary.txt"

# Save both original and cleaned subtitles next to the summary
subtitle_output_file_original="${safe_title}_${timestamp}_original.vtt"
subtitle_output_file_clean="${safe_title}_${timestamp}_clean.vtt"

if [[ -f "$sub_file" ]]; then
  if mv -f "$sub_file" "$subtitle_output_file_original" 2>>"$LOG_FILE"; then
    sub_file="$subtitle_output_file_original"
    log "INFO" "Original subtitle saved to: $sub_file"
  else
    if cp -f "$sub_file" "$subtitle_output_file_original" 2>>"$LOG_FILE"; then
      sub_file="$subtitle_output_file_original"
      log "INFO" "Original subtitle copied to: $sub_file"
    else
      log "WARN" "Failed to place original subtitle next to summary; original remains at: $sub_file"
    fi
  fi
fi

if [[ -f "$clean_sub_file" ]]; then
  if [[ "$clean_sub_file" == "$sub_file" ]]; then
    # Cleaning fell back to original; ensure we still have a clean-named copy
    if cp -f "$sub_file" "$subtitle_output_file_clean" 2>>"$LOG_FILE"; then
      log "INFO" "Clean subtitle copied to: $subtitle_output_file_clean"
    fi
  else
    if mv -f "$clean_sub_file" "$subtitle_output_file_clean" 2>>"$LOG_FILE"; then
      log "INFO" "Clean subtitle saved to: $subtitle_output_file_clean"
    else
      if cp -f "$clean_sub_file" "$subtitle_output_file_clean" 2>>"$LOG_FILE"; then
        log "INFO" "Clean subtitle copied to: $subtitle_output_file_clean"
      else
        log "WARN" "Failed to place cleaned subtitle next to summary"
      fi
    fi
  fi
fi

echo "$summary" > "$output_file"
log "INFO" "Summary written to: $output_file"

echo "Original VTT file: $sub_file"
echo "Cleaned VTT file: $subtitle_output_file_clean"
echo "Summary written to $output_file"
log "INFO" "yt-summarizer completed successfully"

# Open the file with an editor if requested
if [[ "$OPEN_EDITOR" == "true" ]]; then
  open_with_editor "$output_file"
fi

